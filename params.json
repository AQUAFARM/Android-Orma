{"name":"Orma","tagline":"An ORM for Android as a wrapper of SQLiteDatabase","body":"# Orma for Android [![Circle CI](https://circleci.com/gh/gfx/Android-Orma/tree/master.svg?style=svg)](https://circleci.com/gh/gfx/Android-Orma/tree/master) [ ![Download](https://api.bintray.com/packages/gfx/maven/orma/images/download.svg) ](https://bintray.com/gfx/maven/orma/)\r\n\r\n> Easy things should be easy, and hard things should be possible\r\n-- [Larry Wall](http://www.amazon.com/gp/feature.html?ie=UTF8&docId=7137)\r\n\r\nOrma is an ORM (Object-Relation Mapper) for [Android SQLiteDatabase](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html),\r\ngenerating helper classes at compile time with **annotation processing**, inspired in ActiveAndroid, GreenDAO, and Realm.\r\n\r\nOrma has the following features:\r\n\r\n* Fast as hand-written code with `SQLiteOpenHelper`\r\n* Annotation-based schema definitions with POJO classes\r\n* Semi-automatic migration, as well as hand-written migration\r\n\r\n## Getting Started\r\n\r\nOrma requires **JDK 8 (1.8.0_66 or later)** to run annotation processors, and **Android API level 15** to use.\r\n\r\n```groovy\r\n// To use \"apt\" in dependencies\r\n\r\nbuildscript {\r\n    repositories {\r\n        jcenter()\r\n    }\r\n    dependencies {\r\n        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\r\n    }\r\n}\r\n\r\napply plugin: 'com.neenbedankt.android-apt'\r\n```\r\n\r\n```groovy\r\n// To use orma in your Android applications or libraries\r\n\r\ndependencies {\r\n    apt 'com.github.gfx.android.orma:orma-processor:1.0.0'\r\n    compile 'com.github.gfx.android.orma:orma:1.0.0'\r\n}\r\n```\r\n\r\n## Synopsis\r\n\r\nFirst, define model classes annotated with `@Table`, `@Column`, and `@PrimaryKey`.\r\n\r\n```java\r\npackage com.github.gfx.android.orma.example;\r\n\r\nimport com.github.gfx.android.orma.annotation.Column;\r\nimport com.github.gfx.android.orma.annotation.PrimaryKey;\r\nimport com.github.gfx.android.orma.annotation.Table;\r\n\r\nimport android.support.annotation.Nullable;\r\n\r\n@Table\r\npublic class Todo {\r\n\r\n    @PrimaryKey\r\n    public long id;\r\n\r\n    @Column(indexed = true)\r\n    public String title;\r\n\r\n    @Column\r\n    @Nullable // allows NULL (default: NOT NULL)\r\n    public String content;\r\n\r\n    @Column\r\n    public long createdTimeMillis;\r\n}\r\n```\r\n\r\nSecond, create a database handle `OrmaDatabase`, which is generated by `orma-processor`.\r\n\r\nHere is an example to configure `OrmaDatabase`:\r\n\r\n```java\r\n// see OrmaConfiguration for options\r\n// each value is the default.\r\nOrmaDatabase orma = OrmaDatabase.builder(context)\r\n    .readOnMainThread(AccessThreadConstraint.WARNING) // optional\r\n    .writeOnMainThread(AccessThreadConstraint.FATAL) // optional\r\n    .build();\r\n```\r\n\r\nThen, you can create, read, update and delete models:\r\n\r\n```java\r\nTodo todo = ...;\r\n\r\n// create\r\norma.insertIntoTodo(todo);\r\n\r\n// prepared statements with transaction\r\norma.transactionSync( -> { // or transactionAsync() to execute tasks in background\r\n    Inserter<Todo> inserter = orma.prepareInsertIntoTodo();\r\n    inserter.execute(todo);\r\n});\r\n\r\n// read\r\norma.selectFromTodo()\r\n  .titleEq(\"foo\") // equivalent to `where(\"title = ?\", \"foo\")`\r\n  .executeAsObservable() // first-class RxJava interface\r\n  .subscribe(...);\r\n\r\n// update\r\norma.updateTodo()\r\n  .titleEq(\"foo\")\r\n  .content(\"a new content\") // to setup what are updated\r\n  .execute();\r\n\r\n// delete\r\norma.deleteFromTodo()\r\n  .titleEq(\"foo\")\r\n  .execute();\r\n```\r\n\r\nNote that **Orma checks DB access on main thread** in debug build by default.\r\nUse background threads explicitly or RxJava interfaces with `Schedulers.io()`.\r\n\r\n## Motivation\r\n\r\nThere are already [a lot of ORMs](https://android-arsenal.com/tag/69). Why I have to add another wheel?\r\n\r\nThe answer is that I need ORM that have *all* the following features:\r\n\r\n* Fast as hand-written code\r\n* POJO models\r\n  * That is, model classes must have no restriction\r\n  * Might implement `Parcelable` and/or extend any classes\r\n  * They should be passed to another thread\r\n* A Database handle must be an object instance\r\n  * Not a singleton nor static-method based class\r\n* Semi-automatic migration\r\n  * For what can be detected logically\r\n  * i.e. simple `add column` and `drop column`\r\n  * There is an wheel in Perl: [SQL::Translator::Diff](https://metacpan.org/pod/SQL::Translator::Diff)\r\n* Code completion friendly\r\n  * `db.selectFromModel()` is better than `new Select(Model.class)`\r\n* Custom queries\r\n  * `GROUP BY ... HAVING ...`\r\n  * `SELECT max(value), min(value), avg(value), count(value) FROM ...`\r\n\r\nNow they are just what Orma has.\r\n\r\n## The Components\r\n\r\n### Database Handles\r\n\r\nA database handle, named `OrmaDatabase`, is generated by `orma-processor`,\r\nwhich is an entry point of all the high-level database operations.\r\n\r\nFor low-level operations, e.g. executing a raw SQL, you can also use\r\n`OrmaDatabase#getConnection()`, which returns `OrmaConnection`.\r\n\r\n### Models\r\n\r\nA **model** in Orma is a Java class that is annotated with `@Table`, which\r\nhas at least one field annotated with `@Column` or `@PrimaryKey`.\r\n\r\n`orma-processor` generates a `OrmaDatabase` class and helper classes for\r\n each model: `Schema`, `Relation`, `Updater`, and `Deleter`.\r\n\r\nBecause these helper classes are generated at the compile time, you\r\ncan use Orma as a type-safe ORM.\r\n\r\n### Schema Helper\r\n\r\nA Schema helper, e.g. `Todo_Schema`, has metadata for the corresponding model.\r\n\r\nThis is an internal helper class, which is not intended to be used by users.\r\n\r\n### Relation Helper\r\n\r\nA Relation helper, e.g. `Todo_Relation`, is a table manipulator with conditions\r\nand orderings.\r\n\r\nThis is created by the database handle:\r\n\r\n```java\r\npublic static Todo_Relation relation() {\r\n  return orma.relationOfTodo();\r\n}\r\n```\r\n\r\nThis is able to create `Selector`, `Updater`, `Deleter`, and `Inserter` of the specified model. In other words, this is an entry point of model helpers.\r\n\r\n```java\r\nTodo_Relation todos = orma.relationOfTodo();\r\n\r\ntodos.selector().toList(); // Todo_Selector\r\ntodos.updater().content(\"foo\").execute(); // Todo_Updater\r\ntodos.inserter().execute(todo); // Inserter<Todo>\r\ntodos.deleter().execute(); // Todo_Deleter\r\n```\r\n\r\nThis is also a subset of a table which has `ORDER BY` clauses and `WHERE` clauses with some `List`-like methods:\r\n\r\n```java\r\nTodo_Relation todos = orma.relationOfTodo()\r\n  .doneEq(false) // can have conditions\r\n  .orderByCreatedTimeMillis(); // can have orders\r\n\r\n// List-like features:\r\nint count = todos.count();\r\nTodo todo = todos.get(0);\r\n\r\n// Convenience utilities\r\nint position = todos.indexOf(todo);\r\ntodos.deleteWithTransactionAsObservable()\r\n  .subscribeOn(Schedulers.io())\r\n  .observeOn(AndroidSchedulers.mainThread())\r\n  .subscribe(position -> {\r\n    notifyItemRemoved(position); // assumes Adapter#notifyItemRemoved()\r\n  })\r\ntodos.truncateWithTransactionAsObservable()\r\n  .subscribeOn(Schedulers.io())\r\n  .subscribe();\r\n\r\n// Todo_Relation implements Iterable<Todo>\r\nfor (Todo todo : todos) {\r\n  // ...\r\n}\r\n```\r\n\r\n### Selector Helper\r\n\r\nA `Selector` helper, e.g. `Todo_Selector`, is created by the database handle:\r\n\r\n```java\r\nTodo_Selector selector = relation().selector();\r\n// or orma.selectFromTodo();\r\n```\r\n\r\nThis is a query builder for `SELECT ... FROM *` statements.\r\n\r\n### Updater Helper\r\n\r\nAn `Updater` helper, e.g. `Todo_Updater`, is created by the database handle:\r\n\r\n```java\r\nTodo_Updater updater = relation().updater();\r\n// or orma.updateTodo();\r\n```\r\n\r\nThis is a query builder for `UPDATE *` statements.\r\n\r\n### Deleter Helper\r\n\r\nA `Delete` helper, e.g. `Todo_Deleter`, is created by the database handle:\r\n\r\n```java\r\nTodo_Deleter deleter = relation().deleter();\r\n// or orma.deleteFromTodo();\r\n```\r\n\r\nThis is a query builder for `DELETE FROM *` statements.\r\n\r\n## Condition Query Helpers\r\n\r\nThere are Condition Query Helpers, e.g. `titleEq()` shown in the synopsis\r\nsection, which are methods to help make `WHERE` and `ORDER BY` clauses, for\r\n`Relation`, `Selecotr`, `Deleter`, and `Updater`.\r\n\r\nThey are generated for columns with `indexed = true` or the `@PrimaryKey` column.\r\n\r\nHere is a list of Condition Query Helpers that are generated for all the `indexed` columns:\r\n\r\n* `*Eq(value)` to make `WHERE * = ?`, which is also generated for `@PrimaryKey`\r\n* `*NotEq(values)` to make `WHERE * <> ?`\r\n* `*In(values)` to make `WHERE * IN (?, ?, ?, ...)`\r\n* `*NotIn(values)` to make `WHERE * NOT IN (?, ?, ?, ...)`\r\n\r\nThe following are generated for `@Nullable` columns.\r\n\r\n* `*IsNull()` to make `WHERE * IS NULL`\r\n* `*IsNotNull()` to make `WHERE * IS NOT NULL`\r\n\r\nThe following are generated for numeric columns\r\n (i.e. `byte`, `short`, `int`, `long`, `float`, `double`, and their corresponding box types)\r\n\r\n* `*Lt(value)` to make `WHERE * < ?`\r\n* `*Le(value)` to make `WHERE * <= ?`\r\n* `*Gt(value)` to make `WHERE * > ?`\r\n* `*Ge(value)` to make `WHERE * >= ?`\r\n\r\nAnd `ORDER BY` helpers:\r\n\r\n* `orderBy*Asc()` to make `ORDER BY * ASC`\r\n* `orderBy*Desc()` to make `ORDER BY * DESC`\r\n\r\n## The Inserter Helper\r\n\r\nThis is a prepared statement for `INSERT INTO ...` for bulk insertions.\r\n\r\n```java\r\nInserter<Todo> inserter = relation().inserter();\r\n// or orma.insertIntoTodo()\r\n\r\ninserter.execute(todo);\r\ninserter.executeAll(todos);\r\n```\r\n\r\n## Setters and Getters\r\n\r\nOrma uses getters and setters if columns have corresponding methods.\r\n\r\nYou can also connect getters and setters with `@Getter` and `@Setter`\r\nrespectively, which tells `orma-processor` to use accessors.\r\n\r\nEach accessor name can have a column name in SQLite databases,\r\nwhich is inferred from its method name if omitted.\r\n\r\n```java\r\n@Table\r\npublic class KeyValuePair {\r\n\r\n    static final String kKey = \"Key\";\r\n\r\n    @Column(kKey) // specifies the name\r\n    private String key;\r\n\r\n    @Column // omits the name\r\n    private String value;\r\n\r\n    @Getter(kKey)\r\n    public String getKey() {\r\n        return key;\r\n    }\r\n\r\n    @Setter(kKey)\r\n    public void setKey(String key) {\r\n        this.key = key;\r\n    }\r\n\r\n    // used as a getter for the \"value\" column\r\n    // @Getter is optional in this case\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    // used as a setter for the \"value\" column\r\n    // @Setter is optional in this case\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n}\r\n```\r\n\r\n## Immutable Models\r\n\r\nImmutable models, where all the fields are declared with `final`, are supported\r\nby annotating a constructor with `@Setter`.\r\n\r\n```java\r\n@Table\r\npublic class KeyValuePair {\r\n\r\n    @Column\r\n    public final String key;\r\n\r\n    @Column\r\n    public final String value;\r\n\r\n    @Setter\r\n    KeyVakuePair(String key, String value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n```\r\n\r\nCan be declared with custom names:\r\n\r\n```java\r\n@Table\r\npublic class KeyValuePair {\r\n    static final String kKey = \"Key\";\r\n    static final String kValue = \"Value\";\r\n\r\n    @Column(kKey)\r\n    public final String key;\r\n\r\n    @Column(kValue)\r\n    public final String value;\r\n\r\n    KeyVakuePair(@Setter(kKey) String key, @Setter(kValue) String value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Migration\r\n\r\nOrma has pluggable migration mechanism via the `MigrationEngine` interface.\r\n\r\nThe default migration engine is `SchemaDiffMigration`, which handles\r\nschema changes by making diff with old and new table definitions.\r\n\r\nYou can set a custom migration engine to `OrmaDatabase` builders:\r\n\r\n```java\r\nclass CustomMigrationEngine implements MigrationEngine { ... }\r\n\r\nOrmaDatabase orma = OrmaDatabase.builder(context)\r\n  .migrationEngine(new CustomMigrationEngine())\r\n  .build();\r\n```\r\n\r\nSee [migration/README.md](https://github.com/gfx/Android-Orma/tree/master/migration) for details.\r\n\r\n# Type Adapters\r\n\r\nType adapters, which serializes and deserializes custom classes, are supported.\r\n\r\nIf you use type adapters, you can add them to `OrmaDatabase`:\r\n\r\n```java\r\nclass FooAdapter extends AbstractTypeAdapter<Foo> {\r\n    @Override\r\n    @NonNull\r\n    public String serialize(@NonNull Foo source) {\r\n        return ... serialize ...;\r\n    }\r\n\r\n    @Override\r\n    @NonNull\r\n    public Foo deserialize(@NonNull String serialized) {\r\n        return ... deserialize ...;\r\n    }\r\n}\r\n\r\nOrmaDatabase orma = OrmaDatabase.builder(context)\r\n    .addTypeAdapters(new FooAdapter())\r\n    .build();\r\n```\r\n\r\n**The interface is experimental and are likely to change.**\r\n\r\n## Built-In Type Adapters\r\n\r\nThere are a lot of built-in type adapter provided by default, which include:\r\n\r\n* `StringListAdapter` for `List<String>`\r\n* `StringSetAdapter` for `Set<String>`\r\n* `DateAdapter` for `Date`\r\n* `UriAdapter` for `Uri`\r\n\r\nSee [adapter/](library/src/main/java/com/github/gfx/android/orma/adapter)\r\nfor all the adapters.\r\n\r\n## Kotlin Support\r\n\r\nOrma works with Kotlin. Yey!\r\n\r\n## Example\r\n\r\nThere is an example app to demonstrate what Orma does.\r\n\r\nIt also includes a simple benchmark with Realm and hand-written SQLiteDatabase\r\noperations.\r\n\r\nSee [example/](example/) for details.\r\n\r\n## Support\r\n\r\n* Use [GitHub issues](https://github.com/gfx/Android-Orma/issues) for the issue tracker\r\n* Feel free to ask for questions to the author [@\\_\\_gfx\\_\\_](https://twitter.com/__gfx__)\r\n\r\n## Contribution\r\n\r\nPatches welcome!\r\n\r\n## Licenses in Runtime Dependencies\r\n\r\n* https://github.com/ReactiveX/RxJava - Apache Software License 2.0\r\n* [bkiers/sqlite-parser](https://github.com/bkiers/sqlite-parser) - The MIT License\r\n  * The original code of [SQLite.g4](sqliteparser/src/main/antlr/com/github/gfx/android/orma/sqliteparser/g/SQLite.g4)\r\n\r\n## Release Engineering for Maintainers\r\n\r\n```shell\r\n./gradlew bumpMajor # or bumpMinor / bumpPatch\r\ngit add -va\r\nmake publish # run tests, build artifacts, publish to jcenter, and make a tag\r\n```\r\n\r\n## See Also\r\n\r\n* [SQLite](http://sqlite.org/)\r\n* [SQLiteDatabase](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)\r\n* [Version of SQLite used in Android? - Stack Overflow](http://stackoverflow.com/questions/2421189/version-of-sqlite-used-in-android)\r\n\r\n## Author\r\n\r\nFUJI Goro ([gfx](https://github.com/gfx)).\r\n\r\n## License\r\n\r\nCopyright (c) 2015 FUJI Goro (gfx).\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.","google":"UA-71102420-1","note":"Don't delete this file! It's used internally to help with page regeneration."}